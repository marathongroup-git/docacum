
---
id: arinvoice-release-override-completo
title: ARInvoiceEntry — Validaciones previas a Release (análisis y solución con PXOverride)
slug: /acumatica/arinvoice-release-override-completo
description: Explicación por bloques del código original y solución con PXOverride para validar comisiones, fecha y tipo de cambio antes de liberar en Acumatica 2024 R2.
sidebar_position: 11
---

# ARInvoiceEntry — Validaciones previas a **Release**

Este documento explica **por bloques** el código original proporcionado y luego presenta la solución recomendada con **PXOverride**, detallando por qué corrige el problema de validar **después** de liberar.

---

## 1) Código original (tal cual)

```csharp
public delegate IEnumerable ReleaseDelegate(PXAdapter adapter);
[PXUIField(DisplayName = "Release", MapEnableRights = PXCacheRights.Update, MapViewRights = PXCacheRights.Update)]
[PXProcessButton]
public IEnumerable Release(PXAdapter adapter)
{
    IEnumerable rel = Base.Release(adapter);
    if (CurrentDocument.Current != null)
    {
        if (CurrentDocument.Current.DocType == "INV")
        {
            ARRegisterExt aRRegisterExt = PXCache<ARRegister>.GetExtension<ARRegisterExt>(CurrentDocument.Current);
            ValidationSOInvoice.CamposComisiones(aRRegisterExt); // campos comisiones 1er validacion
            if (CurrentDocument.Current.DocDate != Base.Accessinfo.BusinessDate)//fecha documento segunda validacion
            {
                WebDialogResult pregunta = CurrentDocument.Ask(ActionsMessages.Warning, Errores.fechaincorrecta, MessageButtons.YesNo, MessageIcon.Warning);

                if (pregunta == WebDialogResult.No)
                {
                    // Acuminator disable once PX1053 ConcatenationPriorLocalization [Justification]
                    throw new PXException("Liberacion cancelada por peticion del usuario: " + QuerySQL.Vendedor(QuerySQL.ARTran(CurrentDocument.Current.RefNbr).SalesPersonID).SalesPersonCD + " Favor de revisar el documento antes de liberar");

                }
                else
                {
                    //return baseMethod(adapter);
                    return rel;
                }
            }
            if (ValidationSOInvoice.EvaluarTipodeCambio(CurrentDocument.Current) != false)// tipo de cmabio tercera validacion
            {
                //return baseMethod(adapter);
                return rel;
            }
            else
            {
                WebDialogResult question = CurrentDocument.Ask(ActionsMessages.Warning, Errores.errortipocambiofactura, MessageButtons.YesNo, MessageIcon.Warning);
                if (question == WebDialogResult.No)
                {
                    throw new PXException("Liberacion cancelada por peticion del usuario: " + QuerySQL.Vendedor(QuerySQL.ARTran(CurrentDocument.Current.RefNbr).SalesPersonID).SalesPersonCD + " Favor de revisar el documento antes de liberar");
                }
                else
                {
                    PXTrace.WriteError("Proceso aceptado por el usuario:" + " " + QuerySQL.Vendedor(QuerySQL.ARTran(CurrentDocument.Current.RefNbr).SalesPersonID).SalesPersonCD + " Tipo de cambio del dia:  " + ValidationSOInvoice.ObetnerTipoCambioFactura(CurrentDocument.Current, true, false) + " " + "tipo de cambio de la factura:  " + ValidationSOInvoice.ObetnerTipoCambioFactura(CurrentDocument.Current, false, true));
                    CurrentDocument.Cache.SetValueExt(CurrentDocument.Current, "Usrobservaciones", "Proceso aceptado por el usuario:" + " " + QuerySQL.Vendedor(QuerySQL.ARTran(CurrentDocument.Current.RefNbr).SalesPersonID).SalesPersonCD + " Tipo de cambio del dia= " + ValidationSOInvoice.ObetnerTipoCambioFactura(CurrentDocument.Current, true, false) + " " + "tipo de cambio de la factura: " + ValidationSOInvoice.ObetnerTipoCambioFactura(CurrentDocument.Current, false, true));
                    CurrentDocument.Cache.Update(CurrentDocument.Current);
                    Base.Persist();
                    //continua con el proceso normal, solo que va a guardar el usuario que activo la notificacion del tipo de cambio para futuras referencias 
                }
                //return baseMethod(adapter);
                return rel;
            }
        }
    }
    return rel;
}
```

### 1.1 Bloques explicados

**Bloque A — Delegate y atributos**  
- `public delegate IEnumerable ReleaseDelegate(PXAdapter adapter);` declara un *delegate* que sería útil si se hiciera un `[PXOverride]` (no se usa aquí).  
- `[PXUIField]` y `[PXProcessButton]` exponen un **botón Release** propio.

**Bloque B — Llamada inmediata al Release nativo**  
```csharp
IEnumerable rel = Base.Release(adapter);
```
- **Se inicia la liberación de inmediato**, antes de validar. Esta es la raíz del problema: aunque después se pregunte al usuario o se lance una excepción, el proceso ya pudo haber ocurrido.

**Bloque C — Filtros de nulidad y tipo**  
Se verifica que haya documento (`CurrentDocument.Current != null`) y que el tipo sea `"INV"` (literal). Lo robusto es usar `ARDocType.Invoice`.

**Bloque D — Validación de comisiones**  
`ValidationSOInvoice.CamposComisiones(aRRegisterExt)` valida/prepara **comisiones**. Si no lanza excepción, el flujo continúa.

**Bloque E — Validación de fecha con Ask**  
Si `DocDate != BusinessDate`, se muestra `Ask(Yes/No)`:
- **No** → `PXException`.
- **Sí** → `return rel` (pero `rel` ya proviene del release ejecutado al inicio).

**Bloque F — Validación de tipo de cambio**  
- Si `EvaluarTipodeCambio(...) != false` → `return rel` (liberación ya hecha).
- Si `false` → `Ask(Yes/No)`:
  - **No** → excepción.
  - **Sí** → traza informativa y escritura en observaciones; `Persist()` y retorna `rel`.

**Bloque G — Retornos**  
Siempre retorna `rel`, que corresponde a la liberación ya ocurrida.

**Conclusión:** el patrón valida **después** de liberar; aunque el usuario elija **No** o se lance excepción, no se garantiza bloquear el proceso.

---

## 2) Solución recomendada — PXOverride validando **antes**

Se utiliza **`[PXOverride]`** para interceptar el Release nativo y validar **antes** de llamar a `baseMethod(adapter)`. En caso de no cumplir condiciones o de respuesta **No**, se lanza `PXException` y no se ejecuta el long operation. Si el usuario acepta, se **guardan observaciones** y se persiste, y después se libera.

```csharp
using PX.Data;
using PX.Objects.AR;
using System.Collections;

public class ARInvoiceEntryExt : PXGraphExtension<ARInvoiceEntry>
{
    public delegate IEnumerable ReleaseDelegate(PXAdapter adapter);

    // IMPORTANTE: NO poner PXUIField / PXProcessButton en un PXOverride
    [PXOverride]
    public IEnumerable Release(PXAdapter adapter, ReleaseDelegate baseMethod)
    {
        var doc = Base.Document.Current;
        if (doc == null)
            return baseMethod(adapter);

        // Solo facturas
        if (doc.DocType != ARDocType.Invoice)
            return baseMethod(adapter);

        // 1) Validación de comisiones
        var regExt = PXCache<ARRegister>.GetExtension<ARRegisterExt>(doc);
        ValidationSOInvoice.CamposComisiones(regExt);

        // 2) Validación de fecha
        if (doc.DocDate != Base.Accessinfo.BusinessDate)
        {
            var answer = Base.Document.Ask(
                ActionsMessages.Warning,
                Errores.fechaincorrecta,
                MessageButtons.YesNo,
                MessageIcon.Warning
            );

            if (answer == WebDialogResult.No)
                throw new PXException($"Liberación cancelada por petición del usuario: {GetSalespersonCD(doc)}. Favor de revisar el documento antes de liberar");
        }

        // 3) Validación de tipo de cambio
        if (!ValidationSOInvoice.EvaluarTipodeCambio(doc))
        {
            var answer = Base.Document.Ask(
                ActionsMessages.Warning,
                Errores.errortipocambiofactura,
                MessageButtons.YesNo,
                MessageIcon.Warning
            );

            if (answer == WebDialogResult.No)
                throw new PXException($"Liberación cancelada por petición del usuario: {GetSalespersonCD(doc)}. Favor de revisar el documento antes de liberar");

            // Usuario aceptó: registra observaciones ANTES de liberar
            var mensaje =
                $"Proceso aceptado por el usuario: {GetSalespersonCD(doc)} " +
                $"Tipo de cambio del día= {ValidationSOInvoice.ObetnerTipoCambioFactura(doc, true, false)} " +
                $"tipo de cambio de la factura= {ValidationSOInvoice.ObetnerTipoCambioFactura(doc, false, true)}";

            PXTrace.WriteInformation(mensaje);

            // Detecta el nombre correcto del campo en el cache y asigna
            var cache = Base.Document.Cache;
            string fieldName = null;

            // Lista de posibles nombres (ajusta/añade si usaste otro)
            string[] candidates = new[] { "UsrObservaciones", "Usrobservaciones", "usrObservaciones" };

            foreach (var c in candidates)
            {
                if (cache.Fields.Contains(c))
                {
                    fieldName = c;
                    break;
                }
            }

            if (fieldName != null)
            {
                cache.SetValueExt(doc, fieldName, mensaje);
                Base.Document.Update(doc);
                Base.Actions.PressSave();  // o Base.Persist();
            }
            else
            {
                PXTrace.WriteWarning("No se encontró el campo de observaciones en el DAC/Extensión. Verifica el nombre en tu ARRegisterExt/ARInvoiceExt.");
            }
        }

        // 4) Si todo ok, ahora sí: liberar
        return baseMethod(adapter);
    }

    private string GetSalespersonCD(ARRegister doc)
    {
        // Mantengo tu helper actual; si gustas lo cambio a SelectFrom<>
        return QuerySQL.Vendedor(QuerySQL.ARTran(doc.RefNbr).SalesPersonID).SalesPersonCD;
    }
}
```

### Por qué resuelve el problema
- Valida y pregunta **antes** de `baseMethod(adapter)`, por lo que sí **bloquea** la liberación si corresponde.
- Mantiene el **botón nativo** y sus permisos (patrón de override).
- Persiste evidencias (observaciones) **antes** de liberar cuando el usuario acepta.
- Evita dependencias frágiles (se detecta el nombre del campo si no hay BQL field).

---

## 3) Notas y pruebas recomendadas

**Requisitos previos**  
- Campo de observaciones en `ARRegisterExt` o `ARInvoiceExt` (ej. `UsrObservaciones` con `[PXDBString]` y `[PXUIField]`).  
- Métodos utilitarios en `ValidationSOInvoice`: `CamposComisiones`, `EvaluarTipodeCambio`, `ObetnerTipoCambioFactura(...)` (usar el nombre real).

**Pruebas**  
- Fecha distinta → **No** en `Ask` → bloquea.  
- Tipo de cambio inválido → **No** → bloquea / **Sí** → guarda observaciones y libera.  
- Comisiones faltantes → excepción previa a cualquier `Ask`.  
- Documento no `Invoice` → delega al método base sin interferir.
