
# Override de **Release** en `ARInvoiceEntry` con validaciones previas

:::tip üéØ Objetivo
Aplicar validaciones **antes** de ejecutar el proceso nativo de **Release**:
- Comisiones completas
- Fecha del documento vs **BusinessDate**
- Tipo de cambio v√°lido o **confirmado** por el usuario, registrando **observaciones**
:::

:::note üìù Observaciones
Este documento incluye **comentarios de documentaci√≥n** en el c√≥digo (prefijo `// DOC:`) para facilitar la **generaci√≥n autom√°tica** de documentaci√≥n t√©cnica.
:::

---

## 1) C√≥digo original (con resaltado y comentarios)

> Problema principal: se llama a `Base.Release(adapter)` **al inicio** y las validaciones ocurren **despu√©s**, por lo que no bloquean la liberaci√≥n si el usuario cancela.

```csharp title="Release (acci√≥n personalizada original)"
// DOC: Delegate declarado pero no usado con PXOverride en este m√©todo
public delegate IEnumerable ReleaseDelegate(PXAdapter adapter);

[PXUIField(DisplayName = "Release", MapEnableRights = PXCacheRights.Update, MapViewRights = PXCacheRights.Update)]
[PXProcessButton]
public IEnumerable Release(PXAdapter adapter)
{
    // highlight-next-line
    IEnumerable rel = Base.Release(adapter); // DOC: ‚ö†Ô∏è Se libera ANTES de validar (long operation)
    if (CurrentDocument.Current != null)
    {
        // highlight-next-line
        if (CurrentDocument.Current.DocType == "INV") // DOC: Literal; preferible ARDocType.Invoice
        {
            // DOC: Validaci√≥n de comisiones (debe lanzar excepci√≥n si falla)
            ARRegisterExt aRRegisterExt = PXCache<ARRegister>.GetExtension<ARRegisterExt>(CurrentDocument.Current);
            ValidationSOInvoice.CamposComisiones(aRRegisterExt);

            // DOC: Validaci√≥n de fecha (se pregunta DESPU√âS de liberar)
            if (CurrentDocument.Current.DocDate != Base.Accessinfo.BusinessDate)
            {
                WebDialogResult pregunta = CurrentDocument.Ask(ActionsMessages.Warning, Errores.fechaincorrecta, MessageButtons.YesNo, MessageIcon.Warning);

                if (pregunta == WebDialogResult.No)
                {
                    // DOC: Excepci√≥n tard√≠a: la liberaci√≥n ya pudo haberse ejecutado
                    throw new PXException("Liberacion cancelada por peticion del usuario: " +
                        QuerySQL.Vendedor(QuerySQL.ARTran(CurrentDocument.Current.RefNbr).SalesPersonID).SalesPersonCD +
                        " Favor de revisar el documento antes de liberar");
                }
                else
                {
                    return rel; // DOC: Simplemente devuelve el resultado del release ya ejecutado
                }
            }

            // DOC: Validaci√≥n de tipo de cambio
            if (ValidationSOInvoice.EvaluarTipodeCambio(CurrentDocument.Current) != false)
            {
                return rel; // DOC: Igual, el release ya ocurri√≥
            }
            else
            {
                WebDialogResult question = CurrentDocument.Ask(ActionsMessages.Warning, Errores.errortipocambiofactura, MessageButtons.YesNo, MessageIcon.Warning);
                if (question == WebDialogResult.No)
                {
                    throw new PXException("Liberacion cancelada por peticion del usuario: " +
                        QuerySQL.Vendedor(QuerySQL.ARTran(CurrentDocument.Current.RefNbr).SalesPersonID).SalesPersonCD +
                        " Favor de revisar el documento antes de liberar");
                }
                else
                {
                    // DOC: Se registra observaci√≥n pero despu√©s del release
                    PXTrace.WriteError("Proceso aceptado por el usuario: " +
                        QuerySQL.Vendedor(QuerySQL.ARTran(CurrentDocument.Current.RefNbr).SalesPersonID).SalesPersonCD +
                        " Tipo de cambio del dia: " + ValidationSOInvoice.ObetnerTipoCambioFactura(CurrentDocument.Current, true, false) +
                        " tipo de cambio de la factura: " + ValidationSOInvoice.ObetnerTipoCambioFactura(CurrentDocument.Current, false, true));

                    // DOC: Asignaci√≥n por nombre literal, propensa a error tipogr√°fico
                    CurrentDocument.Cache.SetValueExt(CurrentDocument.Current, "Usrobservaciones",
                        "Proceso aceptado por el usuario: " +
                        QuerySQL.Vendedor(QuerySQL.ARTran(CurrentDocument.Current.RefNbr).SalesPersonID).SalesPersonCD +
                        " Tipo de cambio del dia= " + ValidationSOInvoice.ObetnerTipoCambioFactura(CurrentDocument.Current, true, false) +
                        " tipo de cambio de la factura: " + ValidationSOInvoice.ObetnerTipoCambioFactura(CurrentDocument.Current, false, true));

                    CurrentDocument.Cache.Update(CurrentDocument.Current);
                    Base.Persist(); // DOC: Persistencia posterior al release
                }
                return rel;
            }
        }
    }
    return rel;
}
```

:::danger ‚ùó Error encontrado
Se detecta un **defecto de flujo**: el release nativo se invoca **antes** de las validaciones.  
<span style={{color: 'red', fontWeight: 700}}>Impacto:</span> no es posible **bloquear** el release si el usuario responde **No** o si una validaci√≥n falla; la excepci√≥n llega tarde.
:::

---

## 2) Soluci√≥n ‚Äî Patr√≥n correcto con **PXOverride** (validando antes)

Se implementa un **override** de la acci√≥n nativa `Release` en `ARInvoiceEntry` y se ejecutan las validaciones **antes** del `baseMethod(adapter)`.

```csharp title="ARInvoiceEntryExt.cs ‚Äî Override de Release (patr√≥n correcto)"
using PX.Data;
using PX.Objects.AR;
using System.Collections;

public class ARInvoiceEntryExt : PXGraphExtension<ARInvoiceEntry>
{
    // DOC: Delegate requerido por PXOverride
    public delegate IEnumerable ReleaseDelegate(PXAdapter adapter);

    // DOC: Override del Release nativo. No agregar PXUIField / PXProcessButton aqu√≠.
    [PXOverride]
    public IEnumerable Release(PXAdapter adapter, ReleaseDelegate baseMethod)
    {
        // DOC: Guard clause ‚Äî no documento
        var doc = Base.Document.Current;
        if (doc == null)
            return baseMethod(adapter);

        // DOC: Solo facturas (usar constante del framework)
        if (doc.DocType != ARDocType.Invoice)
            return baseMethod(adapter);

        // DOC: (1) Validaci√≥n de comisiones ‚Äî debe lanzar excepci√≥n si falla
        var regExt = PXCache<ARRegister>.GetExtension<ARRegisterExt>(doc);
        ValidationSOInvoice.CamposComisiones(regExt);

        // DOC: (2) Validaci√≥n de fecha ‚Äî preguntar ANTES del long operation
        if (doc.DocDate != Base.Accessinfo.BusinessDate)
        {
            var answer = Base.Document.Ask(
                ActionsMessages.Warning,
                Errores.fechaincorrecta,
                MessageButtons.YesNo,
                MessageIcon.Warning
            );

            if (answer == WebDialogResult.No)
                throw new PXException($"Liberaci√≥n cancelada por petici√≥n del usuario: {GetSalespersonCD(doc)}. Favor de revisar el documento antes de liberar");
        }

        // DOC: (3) Validaci√≥n de tipo de cambio ‚Äî confirmar; si No, bloquear
        if (!ValidationSOInvoice.EvaluarTipodeCambio(doc))
        {
            var answer = Base.Document.Ask(
                ActionsMessages.Warning,
                Errores.errortipocambiofactura,
                MessageButtons.YesNo,
                MessageIcon.Warning
            );

            if (answer == WebDialogResult.No)
                throw new PXException($"Liberaci√≥n cancelada por petici√≥n del usuario: {GetSalespersonCD(doc)}. Favor de revisar el documento antes de liberar");

            // DOC: Usuario acept√≥ -> registrar observaciones ANTES del release
            var mensaje =
                $"Proceso aceptado por el usuario: {GetSalespersonCD(doc)} " +
                $"Tipo de cambio del d√≠a= {ValidationSOInvoice.ObetnerTipoCambioFactura(doc, true, false)} " +
                $"tipo de cambio de la factura= {ValidationSOInvoice.ObetnerTipoCambioFactura(doc, false, true)}";

            PXTrace.WriteInformation(mensaje);

            // DOC: Resolver nombre real del campo en runtime si no hay BQL field
            var cache = Base.Document.Cache;
            string fieldName = null;
            string[] candidates = new[] { "UsrObservaciones", "Usrobservaciones", "usrObservaciones" }; // DOC: Ajustar seg√∫n Ext

            foreach (var c in candidates)
            {
                if (cache.Fields.Contains(c))
                {
                    fieldName = c;
                    break;
                }
            }

            if (fieldName != null)
            {
                cache.SetValueExt(doc, fieldName, mensaje);
                Base.Document.Update(doc);
                Base.Actions.PressSave(); // DOC: Persistir ANTES de liberar para dejar evidencia
            }
            else
            {
                PXTrace.WriteWarning("No se encontr√≥ el campo de observaciones en el DAC/Extensi√≥n. Verifica el nombre en tu ARRegisterExt/ARInvoiceExt.");
            }
        }

        // highlight-next-line
        return baseMethod(adapter); // DOC: Long operation ‚Äî se ejecuta SOLO si todo valid√≥/acept√≥
    }

    // DOC: Helper para obtener el SalespersonCD relacionado
    private string GetSalespersonCD(ARRegister doc)
    {
        // DOC: Se puede migrar a SelectFrom<> para evitar dependencias externas
        return QuerySQL.Vendedor(QuerySQL.ARTran(doc.RefNbr).SalesPersonID).SalesPersonCD;
    }
}
```

:::success ‚úÖ Por qu√© esta soluci√≥n funciona
- Todas las validaciones y `Ask` se eval√∫an **antes** del long operation
- `PXException` **bloquea** la liberaci√≥n si corresponde
- Observaciones se **persisten** antes de liberar (evidencia durable)
- Se preserva el bot√≥n nativo y permisos con el patr√≥n de **override**
:::

---

## 3) Notas, riesgos y pruebas

**Compatibilidad**  
- Dirigido a **Acumatica 2024 R2 (24.210.0019+)**
- Requiere campo de observaciones en `ARRegisterExt` o `ARInvoiceExt` (p. ej. `UsrObservaciones` con `[PXDBString]`/`[PXUIField]`)

**Riesgos comunes**  
- <span style={{color:'red'}}>No bloquear release:</span> ocurre si `Base.Release` se llama antes de validar  
- Campo `UsrObservaciones` no encontrado: ajustar nombre o usar BQL field tipado

**Pruebas recomendadas**  
- Fecha ‚â† BusinessDate ‚Üí responder **No**; debe **bloquear**  
- Tipo de cambio inv√°lido ‚Üí **No** (bloquear) / **S√≠** (guardar observaciones y liberar)  
- Comisiones faltantes ‚Üí excepci√≥n **antes** de cualquier `Ask`  
- Documento no `Invoice` ‚Üí delega al m√©todo base sin interferir

---

## 4) Resumen visual

- üéØ **Objetivo:** validar antes de liberar, con evidencia si se acepta divergencia  
- ‚ùó **Error encontrado:** release ejecutado **antes** de validar  
- ‚úÖ **Soluci√≥n:** `PXOverride` con validaciones y `Ask` **previos** a `baseMethod`  
- üìù **Observaciones:** persistir comentarios del usuario en `UsrObservaciones` antes del release

